# Mercurial extension to push to and pull from Perforce depots.
#
# Copyright 2009-10 Frank Kingswood <frank@kingswood-consulting.co.uk>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2, incorporated herein by reference.

'''Push to or pull from Perforce depots

This extension modifies the remote repository handling so that repository
paths that resemble
    p4://p4server[:port]/clientname
cause operations on the named p4 client specification on the p4 server.
The client specification must already exist on the server before using
this extension. Making changes to the client specification Views causes
problems when synchronizing the repositories, and should be avoided.

Five built-in commands are overridden:

 outgoing  If the destination repository name starts with p4:// then
           this reports files affected by the revision(s) that are
           in the local repository but not in the p4 depot.

 push      If the destination repository name starts with p4:// then
           this exports changes from the local repository to the p4
           depot. If no revision is specified then all changes since
           the last p4 changelist are pushed. In either case, all
           revisions to be pushed are folded into a single p4 changelist.
           Optionally the resulting changelist is submitted to the p4
           server, controlled by the --submit option to push, or by
           setting
              --config perfarce.submit=True
           If the option
              --config perfarce.keep=False
           is False then after a successful submit the files in the
           p4 workarea will be deleted.

 pull      If the source repository name starts with p4:// then this
           imports changes from the p4 depot, automatically creating
           merges of changelists submitted by hg push.
           If the option
              --config perfarce.keep=False
           is False then the import does not leave files in the p4
           workarea, otherwise the p4 workarea will be updated
           with the new files.
           The option
              --config perfarce.tags=False
           can be used to disable pulling p4 tags (a.k.a. labels).
           The option
              --config perfarce.clientuser="search replace"
           can be used to enable quasi-multiuser operation, where
           several users submit changes to p4 with the same user name
           and have their real user name in the p4 client spec.
           The search and replace regular expressions describe
           the substitution to be made to turn a client spec name
           into a user name. If the search regex does not match
           then the username is left unchanged.

 incoming  If the source repository name starts with p4:// then this
           reports changes in the p4 depot that are not yet in the
           local repository.

 clone     If the source repository name starts with p4:// then this
           creates the destination repository and pulls all changes
           from the p4 depot into it.
           If the option
              --config perfarce.lowercasepaths=False
           is True then the import forces all paths in lowercase,
           otherwise paths are recorded unchanged.  Filename case is
           always preserved.
           This setting is a workaround to handle Perforce depots
           containing a path spelled differently from file to file
           (e.g. path/foo and PAth/bar).
'''

from mercurial import cmdutil, commands, context, copies, error, extensions, hg, node, repo, util
from mercurial.node import hex, short
from mercurial.i18n import _

import marshal, tempfile, os, re, string

def uisetup(ui):
    '''monkeypatch pull and push for p4:// support'''

    extensions.wrapcommand(commands.table, 'pull', pull)
    p = extensions.wrapcommand(commands.table, 'push', push)
    p[1].append(('', 'submit', None, 'for p4:// destination submit new changelist to server'))
    extensions.wrapcommand(commands.table, 'incoming', incoming)
    extensions.wrapcommand(commands.table, 'outgoing', outgoing)
    p = extensions.wrapcommand(commands.table, 'clone', clone)
    p[1].append(('', 'startrev', '', 'for p4:// source set initial revisions for clone'))
    hg.schemes['p4'] = p4repo

# --------------------------------------------------------------------------

class p4repo(repo.repository):
    'Dummy repository class so we can use -R for p4submit and p4revert'
    def __init__(self, ui, path):
        self.path = path
        self.ui = ui
        self.root = None

    @staticmethod
    def instance(ui, path, create):
        return p4repo(ui, path)

    def local(self):
        return True
    
    def __getattr__(self, a):
        raise util.Abort(_('not supported for p4'))


def loaditer(f):
    "Yield the dictionary objects generated by p4"
    try:
        while True:
            d = marshal.load(f)
            if not d:
                break
            yield d
    except EOFError:
        pass


class p4client(object):

    def __init__(self, ui, repo, path):
        'initialize a p4client class from the remote path'

        try:
            assert path.startswith('p4://')

            self.ui = ui
            self.repo = repo
            self.server = None
            self.client = None
            self.root = None
            self.keep = ui.configbool('perfarce', 'keep', True)
            self.lowercasepaths = ui.configbool('perfarce', 'lowercasepaths', False)
            self.tags = ui.configbool('perfarce', 'tags', True)

            # caches
            self.clientspec = {}
            self.usercache = {}
            self.p4stat = None
            self.p4pending = None

            # helpers to parse p4 output
            self.re_type = re.compile('([a-z]+)?(text|binary|symlink|apple|resource|unicode|utf\d+)(\+\w+)?$')
            self.re_keywords = re.compile(r'\$(Id|Header|Date|DateTime|Change|File|Revision|Author):[^$\n]*\$')
            self.re_keywords_old = re.compile('\$(Id|Header):[^$\n]*\$')
            self.re_hgid = re.compile('{{mercurial (([0-9a-f]{40})(:([0-9a-f]{40}))?)}}')
            self.re_changeno = re.compile('Change ([0-9]+) created.+')
            self.actions = { 'edit':'M', 'add':'A', 'move/add':'A', 'delete':'R', 'move/delete':'R', 'purge':'R', 'branch':'A', 'integrate':'M' }

            try:
                maxargs = ui.config('perfarce', 'maxargs')
                self.MAXARGS = int(maxargs)
            except:
                if os.name == 'posix':
                    self.MAXARGS = 250
                else:
                    self.MAXARGS = 25

            s, c = path[5:].split('/')
            if ':' not in s:
                s = '%s:1666' % s
            self.server = s
            if c:
                d = self.runs('client -o %s' % util.shellquote(c))
                for n in ['Root'] + ['AltRoots%d' % i for i in range(9)]:
                    if n in d and os.path.isdir(d[n]):
                        self.root = util.pconvert(d[n])
                        break
                if not self.root:
                    ui.note(_('the p4 client root must exist\n'))
                    assert False

                self.clientspec = d
                self.client = c
        except:
            if ui.traceback:ui.traceback()
            raise util.Abort(_('not a p4 repository'))


    def latest(self, tags=False):
        '''Find the most recent changelist which has the p4 extra data which
        gives the p4 changelist it was converted from'''
        for rev in xrange(len(self.repo)-1, -1, -1):
            ctx = self.repo[rev]
            extra = ctx.extra()
            if 'p4' in extra:
                if tags:
                    # if there is a child with p4 tags then return the child revision
                    for ctx2 in ctx.children():
                        if ctx2.description().startswith('p4 tags\n') and ".hgtags" in ctx2:
                            ctx = ctx2
                            break
                return ctx.node(), int(extra['p4'])
        raise util.Abort(_('no p4 changelist revision found'))


    def decodetype(self, p4type):
        'decode p4 type name into mercurial mode string and keyword substitution regex'

        mode = ''
        keywords = None
        p4type = self.re_type.match(p4type)
        if p4type:
            flags = (p4type.group(1) or '') + (p4type.group(3) or '')
            if 'x' in flags:
                mode = 'x'
            if p4type.group(2) == 'symlink':
                mode = 'l'
            if 'ko' in flags:
                keywords = self.re_keywords_old
            elif 'k' in flags:
                keywords = self.re_keywords
        return mode, keywords


    def parsenodes(self, desc):
        'find revisions in p4 changelist description'
        m = self.re_hgid.search(desc)
        nodes = []
        if m:
            try:
                nodes = self.repo.changelog.nodesbetween(
                    [self.repo[m.group(2)].node()], [self.repo[m.group(4) or m.group(2)].node()])[0]
            except:
                if self.ui.traceback:self.ui.traceback()
                self.ui.note(_('ignoring hg revision range %s from p4\n' % m.group(1)))
        return nodes


    def run(self, cmd, files=[], abort=True):
        'Run a P4 command and yield the objects returned'

        c = ['p4', '-G']
        if self.server:
            c.append('-p')
            c.append(self.server)
        if self.client:
            c.append('-c')
            c.append(self.client)
        c.append(cmd)

        old = os.getcwd()
        try:
            if self.root:
                os.chdir(self.root)

            for i in range(0, len(files), self.MAXARGS) or [0]:
                cs = ' '.join(c + [util.shellquote(f) for f in files[i:i + self.MAXARGS]])
                if self.ui.debugflag: self.ui.debug('> %s\n' % cs)

                for d in loaditer(util.popen(cs, mode='rb')):
                    if self.ui.debugflag: self.ui.debug('< %r\n' % d)
                    code = d.get('code')
                    data = d.get('data')
                    if code is not None and data is not None:
                        data = data.strip()
                        if abort and code == 'error':
                            raise util.Abort('p4: %s' % data)
                        elif code == 'info':
                            self.ui.note('p4: %s\n' % data)
                    yield d
        except:
            os.chdir(old)
            raise
        os.chdir(old)


    def runs(self, cmd, one=True, **args):
        '''Run a P4 command and return the number of objects returned,
        or the object itself if exactly one was returned'''
        count = 0
        for d in self.run(cmd, **args):
            if not count:
                value = d
            count += 1
        if count == 1 and one:
            return value
        return count


    def getpending(self, node):
        '''returns True if node is pending in p4 or has been submitted to p4'''
        if self.p4stat is None:
            self._readp4stat()
        return node.node() in self.p4stat

    def getpendinglist(self):
        'return p4 submission state dictionary'
        if self.p4stat is None:
            self._readp4stat()
        return self.p4pending

    def _readp4stat(self):
        '''read pending and submitted changelists into pending cache'''
        self.p4stat = set()
        self.p4pending = []

        p4rev, p4id = self.latest()

        def helper(self,d,p4id):
            c = int(d['change'])
            if c == p4id:
                return

            entry = (c, d['status'] == 'submitted', self.parsenodes(d['desc']))
            self.p4pending.append(entry)
            for n in entry[2]:
                self.p4stat.add(n)

        for d in self.run('changes -l -c %s ...@%d,#head' %
                           (util.shellquote(self.client), p4id)):
            helper(self,d,p4id)
        for d in self.run('changes -l -c %s -s pending' %
                           (util.shellquote(self.client))):
            helper(self,d,p4id)
        self.p4pending.sort()


    def getuser(self, user):
        'get full name and email address of user'
        r = self.usercache.get(user)
        if r:
            return r

        d = self.runs('user -o %s' % util.shellquote(user), abort=False)
        if 'Update' in d:
            try:
                r = '%s <%s>' % (d['FullName'], d['Email'])
                self.usercache[user] = r
                return r
            except:
                pass
        return user


    def change(self, change=None, description=None):
        '''Create a new p4 changelist or update an existing changelist with 
        the given description. Returns the changelist number as a string.'''

        # get changelist data, and update it
        changelist = self.runs('change -o %s' % (change or ''))
        
        if description is not None:
            changelist['Description'] = description

        fn = None
        try:
            # write changelist data to a temporary file
            fd, fn = tempfile.mkstemp(prefix='hg-p4-')
            fp = os.fdopen(fd, 'wb')
            marshal.dump(changelist, fp)
            fp.close()

            # update p4 changelist
            d = self.runs('change -i <%s' % util.shellquote(fn))
            data = d['data']
            if d['code'] == 'info':
                if not self.ui.verbose:
                    self.ui.status('p4: %s\n' % data)
                if not change:
                    m = self.re_changeno.match(data)
                    if m:
                        change = m.group(1)
            else:
                raise util.Abort(_('error creating p4 change: %s') % data)

        finally:
            try:
                if fn: os.unlink(fn)
            except:
                pass

        if not change:
            raise util.Abort(_('did not get changelist number from p4'))
        
        # invalidate cache
        self.p4stat = None
        
        return change


    def describe(self, change, local=None):
        '''Return p4 changelist description, user name and date.
        If the local is true, then also collect a list of 5-tuples
            (depotname, revision, type, action, localname)
        This does not work on pending changelists.
        If local is false then the list returned holds 4-tuples
            (depotname, revision, type, action)
        Retrieving the local filenames is potentially very slow.
        '''

        self.ui.note(_('change %d\n') % change)
        d = self.runs('describe -s %d' % change)
        desc = d['desc']
        user = self.getuser(d['user'])
        date = (int(d['time']), 0)     # p4 uses UNIX epoch

        if local:
            files = self.fstat(change)
        else:
            files = []
            i = 0
            while True:
                df = 'depotFile%d' % i
                if df not in d:
                    break
                df = d[df]
                rv = d['rev%d' % i]
                tp = d['type%d' % i]
                ac = d['action%d' % i]
                files.append((df, int(rv), tp, self.actions[ac]))
                i += 1

        jobs = []
        i = 0
        while True:
            jn = 'job%d' % i
            if jn not in d:
                break
            jn = d[jn]
            js = d['jobstat%d' % i]
            jobs.append((jn, js))
            i += 1

        # quasi-multiuser operation, extract user name from client
        cu = self.ui.config("perfarce","clientuser")
        if cu:
            cus, cur = cu.split(" ",1)
            u, f = re.subn(cus, cur, d['client'])
            if f:
                user = string.capwords(u)

        return desc, user, date, files, jobs


    def fstat(self, change, all=False):
        '''Find local names for all the files belonging to a
        changelist.
        Returns a list of tuples
            (depotname, revision, type, action, localname)
        with only entries for files that appear in the workspace.
        If all is unset considers only files modified by the
        changelist, otherwise returns all files *at* that changelist.
        '''
        result = []

        if all:
            p4cmd = 'fstat ...@%d' % change
        else:
            p4cmd = 'fstat -e %d ...' % change

        if self.lowercasepaths:
            root = util.pconvert(os.path.normcase(self.root))
        else:
            root = self.root

        for d in self.run(p4cmd):
            if len(result) % 250 == 0:
                if hasattr(self.ui, 'progress'):
                    self.ui.progress('p4 fstat', len(result), unit='entries')
                else:
                    self.ui.note('%d files\r' % len(result))
                    self.ui.flush()

            if 'desc' in d or d['clientFile'].startswith('.hg'):
                continue
            else:
                df = d['depotFile']
                rv = d['headRev']
                tp = d['headType']
                ac = d['headAction']
                lf = d['clientFile']
                if self.lowercasepaths:
                   pathname, fname = os.path.split(lf)
                   lf = os.path.join(os.path.normcase(pathname), fname)
                lf = util.pconvert(lf)
                if lf.startswith('%s/' % root):
                    lf = lf[len(root) + 1:]
                else:
                    raise util.Abort(_('invalid p4 local path %s') % lf)
                result.append((df, int(rv), tp, self.actions[ac], lf))

        if hasattr(self.ui, 'progress'):
            self.ui.progress('p4 fstat', None)
        self.ui.note('%d files \n' % len(result))

        return result


    def sync(self, change, fake=False, force=False, all=False, files=[]):
        '''Synchronize the client with the depot at the given change.
        Setting fake adds -k, force adds -f option. The all option is
        not used here, but indicates that the caller wants all the files
        at that revision, not just the files affected by the change.'''

        cmd = 'sync'
        if fake:
            cmd += ' -k'
        elif force:
            cmd += ' -f'
        if not files:
            cmd += ' ...@%d' % change

        n = 0
        for d in self.run(cmd, files=[("%s@%d" % (f, change)) for f in files], abort=False):
            n += 1
            if n % 250 == 0:
                if hasattr(self.ui, 'progress'):
                    self.ui.progress('p4 sync', n, unit='files')
            code = d.get('code')
            if code == 'error':
                data = d['data'].strip()
                if d['generic'] == 17 or d['severity'] == 2:
                    self.ui.note('p4: %s\n' % data)
                else:
                    raise util.Abort('p4: %s' % data)

        if hasattr(self.ui, 'progress'):
            self.ui.progress('p4 sync', None)

        if files and n < len(files):
            raise util.Abort(_('incomplete reply from p4, reduce maxargs'))


    def getfile(self, entry):
        '''Return contents of a file in the p4 depot at the given revision number.
        If self.keep is set, assumes that the client is in sync.
        Raises IOError if the file is deleted.
        '''

        if entry[3] == 'R':
            self.ui.debug('getfile ioerror on %r\n'%(entry,))
            raise IOError()

        try:
            mode, keywords = self.decodetype(entry[2])

            if self.keep:
                fn = os.sep.join([self.root, entry[4]])
                fn = util.localpath(fn)
                if mode == 'l':
                    try:
                        contents = os.readlink(fn)
                    except AttributeError:
                        contents = file(fn, 'rb').read()
                        if contents.endswith('\n'):
                            contents = contents[:-1]
                else:
                    contents = file(fn, 'rb').read()
            else:
                contents = []
                for d in self.run('print %s#%d' % (util.shellquote(entry[0]), entry[1])):
                    code = d['code']
                    if code == 'text' or code == 'binary':
                        contents.append(d['data'])

                contents = ''.join(contents)
                if mode == 'l' and contents.endswith('\n'):
                    contents = contents[:-1]

            if keywords:
                contents = keywords.sub('$\\1$', contents)

            return mode, contents
        except Exception, e:
            if self.ui.traceback:self.ui.traceback()
            raise util.Abort(_('file %s missing in p4 workspace') % entry[4])


    def labels(self, change):
        'Return p4 labels a.k.a. tags at the given changelist'

        tags = []
        if self.tags:
            for d in self.run('labels ...@%d,%d' % (change, change)):
                l = d.get('label')
                if l:
                    tags.append(l)

        return tags


    def submit(self, change):
        '''submit one changelist to p4 and optionally delete the files added 
        or modified in the p4 workarea'''

        cl = None
        for d in self.run('submit -c %s' % change):
            if d['code'] == 'error':
                raise util.Abort(_('error submitting p4 change %s: %s') % (change, d['data']))
            cl = d.get('submittedChange', cl)

        self.ui.note(_('submitted changelist %s\n') % cl)

        if not self.keep:
            # delete the files in the p4 client directory
            self.sync(0)

        # invalidate cache
        self.p4stat = None


    @staticmethod
    def pullcommon(original, ui, repo, source, **opts):
        'Shared code for pull and incoming'

        source = ui.expandpath(source or 'default')
        try:
            client = p4client(ui, repo, source)
        except:
            if ui.traceback:ui.traceback()
            return True, original(ui, repo, source, **opts)

        # if present, --rev will be the last Perforce changeset number to get
        stoprev = opts.get('rev')
        stoprev = stoprev and max(int(r) for r in stoprev) or 0

        # for clone we support a --startrev option to fold initial changelists
        startrev = opts.get('startrev')
        startrev = startrev and int(startrev) or 0

        if len(repo):
            p4rev, p4id = client.latest(tags=True)
        else:
            p4rev = None
            if startrev > 0:
                p4id = startrev
            else:
                p4id = 0

        if stoprev:
           p4cset = '...@%d,@%d' % (p4id, stoprev)
        else:
           p4cset = '...@%d,#head' % p4id

        if startrev < 0:
            # most recent changelists
            p4cmd = 'changes -s submitted -m %d -L %s' % (-startrev, p4cset)
        else:
            p4cmd = 'changes -s submitted -L %s' % p4cset

        changes = []
        for d in client.run(p4cmd):
            c = int(d['change'])
            if startrev or c != p4id:
                changes.append(c)
        changes.sort()

        return False, (client, p4rev, p4id, startrev, changes)


    @staticmethod
    def pushcommon(out, original, ui, repo, dest, **opts):
        'Shared code for push and outgoing'

        dest = ui.expandpath(dest or 'default-push', dest or 'default')
        try:
            client = p4client(ui, repo, dest)
        except:
            if ui.traceback:ui.traceback()
            return True, original(ui, repo, dest, **opts)

        p4rev, p4id = client.latest(tags=True)
        ctx1 = repo[p4rev]
        rev = opts.get('rev')

        if rev:
            n1, n2 = cmdutil.revpair(repo, rev)
            if n2:
                ctx1 = repo[n1]
                ctx1 = ctx1.parents()[0]
                ctx2 = repo[n2]
            else:
                ctx2 = repo[n1]
                ctx1 = ctx2.parents()[0]
        else:
            ctx2 = repo['tip']

        nodes = repo.changelog.nodesbetween([ctx1.node()], [ctx2.node()])[0][1:]

        if not opts['force']:
            # trim off nodes at either end that have already been pushed
            trim = False
            for end in [0, -1]:
                while nodes:
                    n = repo[nodes[end]]
                    if client.getpending(n):
                        del nodes[end]
                        trim = True
                    else:
                        break

            # recalculate the context
            if trim and nodes:
                ctx1 = repo[nodes[0]].parents()[0]
                ctx2 = repo[nodes[-1]]

            # check that remaining nodes have not already been pushed
            for n in nodes:
                n = repo[n]
                fail = False
                if client.getpending(n):
                    fail = True
                for ctx3 in n.children():
                    extra = ctx3.extra()
                    if 'p4' in extra:
                        fail = True
                        break
                if fail:
                    raise util.Abort(_('can not push, changeset %s is already in p4' % n))

        # find changed files
        if not nodes:
            mod = add = rem = []
            cpy = {}
        else:
            mod, add, rem = repo.status(node1=ctx1.node(), node2=ctx2.node())[:3]
            mod = [(f, ctx2.flags(f)) for f in mod]
            add = [(f, ctx2.flags(f)) for f in add]
            rem = [(f, "") for f in rem]

            cpy = copies.copies(repo, ctx1, ctx2, repo[node.nullid])[0]

            # forget about copies with changes to the data
            forget = []
            for c in cpy:
                if ctx2.flags(c) != ctx1.flags(c) or ctx1[cpy[c]].cmp(ctx2[c].data()):
                    forget.append(c)
            for c in forget:
                del cpy[c]

            # remove .hg* files (mainly for .hgtags and .hgignore)
            for changes in [mod, add, rem]:
                i = 0
                while i < len(changes):
                    f = changes[i][0]
                    if f.startswith('.hg'):
                        del changes[i]
                    else:
                        i += 1

        if not (mod or add or rem):
            ui.status(_('no changes found\n'))
            return True, 0

        # detect MQ
        try:
            mq = repo.changelog.nodesbetween([repo['qbase'].node()], nodes)[0]
            if mq:
                raise util.Abort(_('source has mq patches applied'))
        except error.RepoLookupError:
            pass

        # create description
        desc = []
        for n in nodes:
            desc.append(repo[n].description())

        if len(nodes) > 1:
            h = [repo[nodes[0]].hex()]
        else:
            h = []
        h.append(repo[nodes[-1]].hex())

        desc='\n* * *\n'.join(desc) + '\n\n{{mercurial %s}}\n' % (':'.join(h))

        return False, (client, p4rev, p4id, nodes, ctx2, desc, mod, add, rem, cpy)


# --------------------------------------------------------------------------

def incoming(original, ui, repo, source='default', **opts):
    '''show changes that would be pulled from the p4 source repository'''

    done, r = p4client.pullcommon(original, ui, repo, source, **opts)
    if done:
        return r

    client, p4rev, p4id, startrev, changes = r
    for c in changes:
        desc, user, date, files, jobs = client.describe(c, local=ui.verbose)
        tags = client.labels(c)

        ui.write(_('changelist:  %d\n') % c)
        # ui.write(_('branch:      %s\n') % branch)
        for tag in tags:
            ui.write(_('tag:         %s\n') % tag)
        # ui.write(_('parent:      %d:%s\n') % parent)
        ui.write(_('user:        %s\n') % user)
        ui.write(_('date:        %s\n') % util.datestr(date))
        if ui.verbose:
            ui.write(_('files:       %s\n') % ' '.join(f[4] for f in files))

        if desc:
            if ui.verbose:
                ui.write(_('description:\n'))
                ui.write(desc)
                ui.write('\n')
            else:
                ui.write(_('summary:     %s\n') % desc.splitlines()[0])

        ui.write('\n')


def pull(original, ui, repo, source=None, **opts):
    '''Wrap the pull command to look for p4 paths, import changelists'''

    done, r = p4client.pullcommon(original, ui, repo, source, **opts)
    if done:
        return r

    client, p4rev, p4id, startrev, changes = r
    entries = {}
    c = 0

    def getfilectx(repo, memctx, fn):
        'callback to read file data'
        mode, contents = client.getfile(entries[fn])
        return context.memfilectx(fn, contents, 'l' in mode, 'x' in mode, None)

    # for clone we support a --startrev option to fold initial changelists
    if startrev:
        if len(changes) < 2:
            raise util.Abort(_('with --startrev there must be at least two revisions to clone'))
        if startrev < 0:
            startrev = changes[0]
        else:
            if changes[0] != startrev:
                raise util.Abort(_('changelist for --startrev not found'))

    if client.lowercasepaths:
        ui.status(_("converting pathnames to lowercase.\n"))

    tags = {}

    try:
        for c in changes:
            desc, user, date, files, jobs = client.describe(c)
            files = client.fstat(c, all=bool(startrev))

            if client.keep:
                if startrev:
                    client.sync(c, all=True, force=True)
                else:
                    client.runs('revert -k', files=[f[0] for f in files],
                                abort=False)
                    client.sync(c, force=True, files=[f[0] for f in files])

            entries = dict((f[4], f) for f in files)

            nodes = client.parsenodes(desc)
            if nodes:
                parent = nodes[-1]
            else:
                parent = None

            if startrev:
                # no 'p4' data on first revision as it does not correspond
                # to a p4 changelist but to all of history up to a point
                extra = {}
                startrev = None
            else:
                extra = {'p4':c}

            ctx = context.memctx(repo, (p4rev, parent), desc,
                                 [f[4] for f in files], getfilectx,
                                 user, date, extra)

            p4rev = repo.commitctx(ctx)
            ctx = repo[p4rev]

            for l in client.labels(c):
                tags[l] = (c, ctx.hex())

            ui.note(_('added changeset %d:%s\n') % (ctx.rev(), ctx))

    finally:
        if tags:
            p4rev, p4id = client.latest()
            ctx = repo[p4rev]

            if '.hgtags' in ctx:
                tagdata = [ctx.filectx('.hgtags').data()]
            else:
                tagdata = []

            desc = ['p4 tags']
            for l in sorted(tags):
                t = tags[l]
                desc.append('   %s @ %d' % (l, t[0]))
                tagdata.append('%s %s\n' % (t[1], l))

            def getfilectx(repo, memctx, fn):
                'callback to read file data'
                assert fn=='.hgtags'
                return context.memfilectx(fn, ''.join(tagdata), False, False, None)

            ctx = context.memctx(repo, (p4rev, None), '\n'.join(desc),
                                 ['.hgtags'], getfilectx)
            p4rev = repo.commitctx(ctx)
            ctx = repo[p4rev]
            ui.note(_('added changeset %d:%s\n') % (ctx.rev(), ctx))

    if opts['update']:
        return hg.update(repo, 'tip')


def clone(original, ui, source, dest=None, **opts):
    '''Wrap the clone command to look for p4 source paths, do pull'''

    try:
        client = p4client(ui, None, source)
    except:
        if ui.traceback:ui.traceback()
        return original(ui, source, dest, **opts)

    if dest is None:
        dest = hg.defaultdest(source)
        ui.status(_("destination directory: %s\n") % dest)
    else:
        dest = ui.expandpath(dest)
    dest = hg.localpath(dest)

    if not hg.islocal(dest):
        raise util.Abort(_("destination '%s' must be local") % dest)

    if os.path.exists(dest):
        if not os.path.isdir(dest):
            raise util.Abort(_("destination '%s' already exists") % dest)
        elif os.listdir(dest):
            raise util.Abort(_("destination '%s' is not empty") % dest)

    repo = hg.repository(ui, dest, create=True)

    opts['update'] = not opts['noupdate']
    opts['force'] = None

    try:
        r = pull(None, ui, repo, source=source, **opts)
    finally:
        fp = repo.opener("hgrc", "w", text=True)
        fp.write("[paths]\n")
        fp.write("default = %s\n" % source)
        fp.write("\n[perfarce]\n")
        fp.write("keep = %s\n" % client.keep)
        fp.write("lowercasepaths = %s\n" % client.lowercasepaths)
        fp.write("tags = %s\n" % client.tags)
        cu = ui.config("perfarce", "clientuser")
        if cu:
            fp.write("clientuser = %s\n" % cu)
        fp.close()

    return r


# --------------------------------------------------------------------------

def outgoing(original, ui, repo, dest=None, **opts):
    '''Wrap the outgoing command to look for p4 paths, report changes'''
    done, r = p4client.pushcommon(True, original, ui, repo, dest, **opts)
    if done:
        return r
    client, p4rev, p4id, nodes, ctx, desc, mod, add, rem, cpy = r

    if ui.quiet:
        # for thg integration until we support templates
        for n in nodes:
            ui.write('%s\n' % repo[n].hex())
    else:
        ui.write(desc)
        ui.write('\naffected files:\n')
        cwd = repo.getcwd()
        for char, files in zip('MAR', (mod, add, rem)):
            for f in files:
                ui.write('%s %s\n' % (char, repo.pathto(f[0], cwd)))
        ui.write('\n')


def push(original, ui, repo, dest=None, **opts):
    '''Wrap the push command to look for p4 paths, create p4 changelist'''

    done, r = p4client.pushcommon(False, original, ui, repo, dest, **opts)
    if done:
        return r
    client, p4rev, p4id, nodes, ctx, desc, mod, add, rem, cpy = r

    # sync to the last revision pulled, converted or submitted
    for e in client.getpendinglist():
        if e[1]:
            p4id=e[0]

    if client.keep:
        client.sync(p4id)
    else:
        client.sync(p4id, fake=True)
        client.sync(p4id, force=True, files=[f[0] for f in mod])

    # attempt to reuse an existing changelist
    use = ''
    for d in client.run('changes -s pending -c %s -l' % client.client):
        if d['desc'] == desc:
            use = d['change']

    # revert any other changes to the files in existing changelist
    if use:
        ui.note(_('reverting: %s\n') % ' '.join(f[0] for f in mod + add + rem))
        client.runs('revert -c %s' % use,
                    files=[f[0] for f in mod + add + rem], abort=False)

    # create new changelist
    use = client.change(use, desc)

    # sort out the copies from the adds
    ntg = [(cpy[f[0]], f[0]) for f in add if f[0] in cpy]
    add = [f for f in add if f[0] not in cpy]

    def modal(note, cmd, files):
        'Run command grouped by file mode'
        ui.note(note % ' '.join(f[0] for f in files))
        modes = set(f[1] for f in files)
        for mode in modes:
            opt = ""
            if 'l' in mode:
                opt = "symlink"
            if 'x' in mode:
                opt += "+x"
            opt = opt and " -t " + opt
            partial = [f[0] for f in files if f[1]==mode]
            if partial:
                for d in client.run(cmd + opt, files=partial):
                    if d['code'] == 'info':
                        data = d['data']
                        if "- use 'reopen'" in data:
                            raise util.Abort('p4: %s' % data)

    try:
        # now add/edit/delete the files
        if mod:
            modal(_('opening for edit: %s\n'), 'edit -c %s' % use, mod)

        if mod or add:
            ui.note(_('retrieving file contents...\n'))
            opener = util.opener(client.root)

            for name, mode in mod + add:
                ui.debug(_('writing: %s\n') % name)
                if 'l' in mode:
                    opener.symlink(ctx[name].data(), name)
                else:
                    fp = opener(name, mode="w")
                    fp.write(ctx[name].data())
                    fp.close()
                util.set_flags(os.path.join(client.root, name), 'l' in mode, 'x' in mode)

        if add:
            modal(_('opening for add: %s\n'), 'add -c %s' % use, add)

        if ntg:
            ui.note(_('opening for integrate: %s\n') % ' '.join(f[1] for f in ntg))
            for f in ntg:
                client.runs('integrate -c %s %s %s' % (use, f[0], f[1]))

        if rem:
            modal(_('opening for delete: %s\n'), 'delete -c %s' % use, rem)

        # submit the changelist to p4 if --submit was given
        if opts['submit'] or ui.configbool('perfarce', 'submit', default=False):
            client.submit(use)
        else:
            ui.note(_('pending changelist %s\n') % use)

    except:
        revert(ui, repo, use, **opts)
        raise


# --------------------------------------------------------------------------

def subrevcommon(mode, ui, repo, *changes, **opts):
    'Collect list of changelist numbers from commandline'

    if repo.path.startswith('p4://'):
        dest = repo.path
    else:
        dest = ui.expandpath('default-push', 'default')
    client = p4client(ui, repo, dest)

    if changes:
        changes = [int(c) for c in changes]
    elif opts['all']:
        changes = [e[0] for e in client.getpendinglist() if not e[1]]
        if not changes:
            raise util.Abort(_('no pending changelists to %s') % mode)
    else:
        raise util.Abort(_('no changelists specified'))

    return client, changes


def submit(ui, repo, *changes, **opts):
    'submit one or more changelists to the p4 depot.'

    client, changes = subrevcommon('submit', ui, repo, *changes, **opts)

    for c in changes:
        ui.status(_('submitting: %d\n') % c)
        desc, user, date, files, jobs = client.describe(c)
        client.submit(c)


def revert(ui, repo, *changes, **opts):
    'revert one or more pending changelists and all opened files.'

    client, changes = subrevcommon('revert', ui, repo, *changes, **opts)

    for c in changes:
        ui.status(_('reverting: %d\n') % c)
        try:
            desc, user, date, files, jobs = client.describe(c)
        except:
            if self.ui.traceback:self.ui.traceback()
            files = None

        if files is not None:
            files = [f[0] for f in files]
            if files:
                ui.note(_('reverting: %s\n') % ' '.join(files))
                client.runs('revert', files=files, abort=False)

            jobs = [j[0] for j in jobs]
            if jobs:
                ui.note(_('unfixing: %s\n') % ' '.join(jobs))
                client.runs('fix -d -c %d' % c, files=jobs, abort=False)

            ui.note(_('deleting: %d\n') % c)
            client.runs('change -d %d' %c , abort=False)


def pending(ui, repo, dest=None, **opts):
    'report changelists already pushed and pending for submit in p4'

    dest = ui.expandpath(dest or 'default-push', dest or 'default')
    client = p4client(ui, repo, dest)

    hexfunc = ui.verbose and hex or short
    pl = client.getpendinglist()
    if pl:
        w = max(len(str(e[0])) for e in pl)
        for e in pl:
            ui.write('%*d %s %s\n' % (-w, e[0], ['p','s'][e[1]], ' '.join(hexfunc(n) for n in e[2])))


def identify(ui, repo, *args, **opts):
    '''show p4 and hg revisions for the most recent p4 changelist

    With no revision, show a summary of the most recent revision
    in the repository that was converted from p4.
    Otherwise, find the p4 changelist for the revision given.
    '''

    rev = opts.get('rev')
    if rev:
        ctx = repo[rev]
        extra = ctx.extra()
        if 'p4' not in extra:
            raise util.Abort(_('no p4 changelist revision found'))
        changelist = int(extra['p4'])
    else:
        client = p4client(ui, repo, 'p4:///')
        p4rev, changelist = client.latest()
        ctx = repo[p4rev]

    num = opts.get('num')
    doid = opts.get('id')
    dop4 = opts.get('p4')
    default = not (num or doid or dop4)
    output = []

    if default or dop4:
        output.append(str(changelist))
    if num:
        output.append(str(ctx.rev()))
    if default or doid:
        output.append(str(ctx))

    ui.write("%s\n" % ' '.join(output))


cmdtable = {
    # 'command-name': (function-call, options-list, help-string)
    'p4pending':
        (   pending,
            [ ],
            'hg p4pending [p4://server/client]'),
    'p4revert':
        (   revert,
            [ ('a', 'all', None,   _('revert all changelists listed by p4pending')) ],
            'hg p4revert [-a] changelist...'),
    'p4submit':
        (   submit,
            [ ('a', 'all', None,   _('submit all changelists listed by p4pending')) ],
            'hg p4submit [-a] changelist...'),
    'p4identify':
        (   identify,
            [ ('r', 'rev', '',   _('identify the specified revision')),
              ('n', 'num', None, _('show local revision number')),
              ('i', 'id',  None, _('show global revision id')),
              ('p', 'p4',  None, _('show p4 revision number')),
            ],
            'hg p4identify [-inp] [-r REV]'
        )
}
